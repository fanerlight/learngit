git add filename(s) : append the workspace files to the stage 
git commit -m "comment": transfer the stage files to the head/master
查看当前版本库中有多少提交，使用git log，可以得到历史提交的版本号
可以用git reset version_number 进行回溯或者前进
如果回到过去之后，想要回到未来，可用git reflog查看未来版本号
查看当前git版本库状态，使用git status，可以知道工作区、暂存区中的修改记录与提交情况
比较工作区和master中的版本区别，使用git diff version_number
如果对工作区的文件进行了错误的修改，但还未进行git add 将其添加到stage暂存区，可以使用git checkout --  filename进行撤销修改。
错误修改如果已经add到stage暂存区，可以使用git reset HEAD filename将该文件重新放回workspace
如果将错误修改已经commit到本地版本库，使用git reset version_number 进行历史穿越。
因此git reset不光可以用于stage的恢复，也可以用于整个版本库的回溯。但如果将修改提交到了远程版本库，就可能会被其他人看到。
/*————————如果文件误删怎么办——————————*/
在工作区删除了某个文件，但是还没有add到stge，想要恢复，使用git checkout -- filename。其实git checkout的作用，就是把本地版本库的最近一次的备份（检查点）同步到workspace，道理和之前文件内容作了修改但还没有add是一样的。
/*———————git远程仓库：Github——————————*/
为了在多台机器上协同工作，可以将本地的仓库托管到远程服务器，而后在另一个本地上从远程服务器同步该仓库，从而使得多个本地上存在仓库的备份。同时如果是多人协作场景，则每个人在远程仓库上的提交都可以共享。
首先需要绑定Github上面的仓库和本地仓库之间的关系：git remote add origin git@github.com:user_name/repo_name
上面命令中，origin表示远程库的名字，是默认习惯命名。
接着使用git push -u origin master将本地仓库推送到关联的远程库上。其中-u表示第一次推送时，git会将本地master分支推动到远程master分支，并且将master分支也关联起来，在之后的推送中就可以简化命令。以后只要git push origin master即可完成本地到远程的推送。
最后，如果需要解除本地库和远程库的绑定，使用git remote rm repo_name。注意远程库并没有被删除，只是断开了绑定，真正删除需要上github手动操作。
/*——————————分支管理————————————*/
对分支的理解，是时间线上的一些结点。每次commit就会在当前分支上产生一个新的结点，之前所学的reset就是在这些结点上进行转移。
master是一个主线分支，在仓库创建的时候自带该分支，所以在仓库上的改动首先默认是在master分支上进行的，名为master的结点会随着改动。在仓库中有个HEAD指针，永远指向当前的活动结点。
创建新分支后，该分支对应前进结点是当前结点；将活动转移到该分支之后，HEAD指针就指向当前分支的前进结点。
git branch <branch_name>创建分支
git switch <branch_name>切换到指定分支
以上两步骤也可合并为一步：git checkout -b <branch_name>
查看当前仓库的分支情况：git branch
切换branch:git switch <branch_name>，其实就是将HEAD指针指向不同branch的前进结点。
合并其他branch到当前branch：git merge <branch_name>
删除其他branch：git branch -d <branch_name>
/*————————冲突解决————————*/
所谓冲突是指两个分支在公共结点之后有岔路存在，这时调用git merge <branch_name>就会合并失败，因为不同岔路会有不同的文件存在。git merge会提示有哪些文件冲突，之后直接打开文件可以看到不同分支下的情况，直接在文件里消除冲突，之后即可合并。
/*—————————管理分支策略—————————*/
jinyongjinyongjinyongjinyongjinyong
不能提交到master中，会影响到笔记。那就重新开一个分支。